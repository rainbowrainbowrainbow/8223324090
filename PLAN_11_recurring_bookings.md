# Feature #11: Recurring Bookings (–ü–æ–≤—Ç–æ—Ä—é–≤–∞–Ω—ñ –±—Ä–æ–Ω—é–≤–∞–Ω–Ω—è)

> Plan created: 2026-02-14
> Status: DRAFT
> Affects: DB, Backend, Frontend, Scheduler, Telegram

---

## 1. Current Booking Structure (–ê–Ω–∞–ª—ñ–∑ –ø–æ—Ç–æ—á–Ω–æ—ó —Å–∏—Å—Ç–µ–º–∏)

### 1.1 Booking Table Schema

```sql
bookings (
    id VARCHAR(50) PK,          -- BK-YYYY-NNNN (generated by booking_counter)
    date VARCHAR(20),            -- '2026-02-15'
    time VARCHAR(10),            -- '14:00'
    line_id VARCHAR(100),        -- 'line1_2026-02-15'
    program_id VARCHAR(50),      -- 'kv1'
    program_code VARCHAR(20),    -- '–ö–í1'
    label VARCHAR(100),          -- '–ö–í1(60)'
    program_name VARCHAR(100),
    category VARCHAR(50),        -- 'quest'
    duration INTEGER,            -- 60 (minutes)
    price INTEGER,               -- 2200 (UAH)
    hosts INTEGER,               -- 1 or 2
    second_animator VARCHAR(100),-- name of second animator line
    pinata_filler VARCHAR(50),   -- e.g. '–°–æ–ª–æ–¥–æ—â—ñ'
    costume VARCHAR(100),
    room VARCHAR(100),           -- 'Marvel'
    notes TEXT,
    created_by VARCHAR(50),
    created_at TIMESTAMP,
    updated_at TIMESTAMP,
    linked_to VARCHAR(50),       -- FK to parent booking id
    status VARCHAR(20),          -- 'confirmed'/'preliminary'/'cancelled'
    kids_count INTEGER,
    group_name VARCHAR(100),
    telegram_message_id INTEGER,
    extra_data JSONB             -- e.g. { tshirt_sizes: { S: 3, M: 2 } }
)
```

### 1.2 Main + Linked Bookings Relationship

**How it works now:**

1. **Main booking** ‚Äî the primary booking on Animator 1's timeline (`linked_to = NULL`).
2. **Linked booking** ‚Äî a shadow copy on Animator 2's timeline (`linked_to = main.id`). Created when a program requires `hosts > 1` (2-animator programs like –ö–í4, –ö–í5, –ö–í7, –ö–í8, –ö–í9, –ö–í10, –ö–í11, –ü–∞–ø–µ—Ä–æ–≤–µ —à–æ—É).
3. **Extra host booking** ‚Äî optional third linked booking for "–î–æ–¥–∞—Ç–∫–æ–≤–∏–π –≤–µ–¥—É—á–∏–π" toggle (`program_id = 'anim_extra'`, `linked_to = main.id`).

**Creation flow (POST `/api/bookings/full`):**
- Single transaction: BEGIN ‚Üí create main ‚Üí create each linked ‚Üí history ‚Üí COMMIT
- Each linked booking gets its own `BK-YYYY-NNNN` id via `generateBookingNumber()`
- Linked bookings share: date, time, duration, room, program, status
- Linked bookings differ: `line_id` (different animator line), `linked_to` (points to main)
- Conflict check: main line + each linked line checked separately within the transaction

**Update flow (PUT `/api/bookings/:id`):**
- When `secondAnimator` changes on main booking: old linked bookings are deleted, new ones created
- When `secondAnimator` stays the same: basic fields (date, time, duration, status, room) cascade to linked bookings
- When `secondAnimator` is set but no linked booking exists (old bug): creates missing linked booking

**Delete flow (DELETE `/api/bookings/:id`):**
- `DELETE FROM bookings WHERE id = $1 OR linked_to = $1` ‚Äî cascades to all linked bookings
- Frontend also resolves linked‚Üímain before deleting (always deletes the main)

### 1.3 Conflict Checks (3 layers)

| Check | Function | What it does |
|---|---|---|
| **Line overlap** | `checkServerConflicts(client, date, lineId, time, duration, excludeId)` | Checks if any booking on the same `line_id` overlaps in time. Also detects "no pause" (< 15 min gap). |
| **Room overlap** | `checkRoomConflict(client, date, room, time, duration, excludeId)` | Checks if the room is already occupied at that time (ignores '–Ü–Ω—à–µ'). |
| **Program duplicate** | `checkServerDuplicate(client, date, programId, time, duration, excludeId)` | Prevents the same non-animation program from being booked twice at the same time. |

All three checks accept an `excludeId` parameter for edit mode.

### 1.4 Animator Lines

Lines are date-specific: `line_id = 'line1_2026-02-15'`. Stored in `lines_by_date` table with `(date, line_id)` UNIQUE constraint. Default 2 lines seeded via `ensureDefaultLines(date)`. Line names can change day-to-day (renamed animators), which is why `second_animator` stores the **name** and the system resolves to `line_id` at runtime.

**Critical for recurring:** Lines for future dates may not exist yet. Must call `ensureDefaultLines(targetDate)` before creating recurring instances, or resolve line assignment at generation time.

---

## 2. Database Design

### 2.1 New Table: `recurring_booking_templates`

```sql
CREATE TABLE IF NOT EXISTS recurring_booking_templates (
    id SERIAL PRIMARY KEY,

    -- Schedule pattern
    recurrence_pattern VARCHAR(20) NOT NULL,  -- 'weekly', 'biweekly', 'monthly', 'custom'
    recurrence_days VARCHAR(50),               -- for custom: '1,3,5' (1=Mon...7=Sun)
    monthly_rule VARCHAR(30),                  -- for monthly: '1st_sat', '2nd_sun', 'last_fri', etc.
    interval_weeks INTEGER DEFAULT 1,          -- 1=weekly, 2=biweekly

    -- Date range
    date_from VARCHAR(20) NOT NULL,            -- start date: '2026-03-01'
    date_to VARCHAR(20),                       -- end date (NULL = indefinite)

    -- Booking template data (mirrors bookings table)
    program_id VARCHAR(50) NOT NULL,
    program_code VARCHAR(20),
    label VARCHAR(100),
    program_name VARCHAR(100),
    category VARCHAR(50),
    duration INTEGER NOT NULL,
    price INTEGER,
    hosts INTEGER DEFAULT 1,
    second_animator_name VARCHAR(100),   -- store NAME, resolve to line_id at generation
    pinata_filler VARCHAR(50),
    costume VARCHAR(100),
    room VARCHAR(100),
    time VARCHAR(10) NOT NULL,           -- '14:00'
    preferred_line_name VARCHAR(100),    -- store NAME, resolve at generation
    notes TEXT,
    group_name VARCHAR(100),
    kids_count INTEGER,
    extra_data JSONB,

    -- Metadata
    created_by VARCHAR(50),
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_recurring_templates_active
    ON recurring_booking_templates(is_active);
CREATE INDEX IF NOT EXISTS idx_recurring_templates_pattern
    ON recurring_booking_templates(recurrence_pattern);
```

### 2.2 New Column on `bookings` Table

```sql
ALTER TABLE bookings ADD COLUMN IF NOT EXISTS recurring_template_id INTEGER;
CREATE INDEX IF NOT EXISTS idx_bookings_recurring_template_id ON bookings(recurring_template_id);
```

This links each generated booking instance back to its template, enabling:
- "Edit all future" / "Delete entire series"
- Identifying which bookings are auto-generated vs manually created
- Preventing duplicate generation (dedup check)

### 2.3 New Table: `recurring_booking_skips` (Conflict log)

```sql
CREATE TABLE IF NOT EXISTS recurring_booking_skips (
    id SERIAL PRIMARY KEY,
    template_id INTEGER NOT NULL,
    date VARCHAR(20) NOT NULL,
    reason VARCHAR(50) NOT NULL,         -- 'line_conflict', 'room_conflict', 'manual_skip'
    details TEXT,                          -- human-readable conflict info
    notified BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(template_id, date)
);

CREATE INDEX IF NOT EXISTS idx_recurring_skips_template ON recurring_booking_skips(template_id);
CREATE INDEX IF NOT EXISTS idx_recurring_skips_date ON recurring_booking_skips(date);
```

### 2.4 Reuse of Existing Patterns

The `afisha_templates` table (v8.0) already uses:
```
recurrence_pattern: 'daily' | 'weekdays' | 'weekends' | 'weekly' | 'custom'
recurrence_days: '1,3,5'
date_from / date_to
is_active
```

We **extend** this pattern vocabulary with:
- `'biweekly'` ‚Äî every 2 weeks (using `interval_weeks = 2`)
- `'monthly'` ‚Äî Nth weekday of month (using `monthly_rule` field)

The `shouldTemplateRunOnDate()` function from `routes/afisha.js` can be **generalized** into a shared utility:

```javascript
// utils/recurrence.js ‚Äî shared by afisha templates, task templates, booking templates
function shouldRunOnDate(template, dateStr, dateObj) {
    if (template.date_from && dateStr < template.date_from) return false;
    if (template.date_to && dateStr > template.date_to) return false;
    const dayOfWeek = dateObj.getDay() || 7; // 1=Mon...7=Sun

    switch (template.recurrence_pattern) {
        case 'daily': return true;
        case 'weekdays': return dayOfWeek <= 5;
        case 'weekends': return dayOfWeek >= 6;
        case 'weekly':
            // Check specific day + interval
            if (template.recurrence_days) {
                const days = template.recurrence_days.split(',').map(d => parseInt(d.trim()));
                if (!days.includes(dayOfWeek)) return false;
            }
            if (template.interval_weeks && template.interval_weeks > 1) {
                return isCorrectWeekInterval(template.date_from, dateStr, template.interval_weeks);
            }
            return true;
        case 'biweekly':
            if (template.recurrence_days) {
                const days = template.recurrence_days.split(',').map(d => parseInt(d.trim()));
                if (!days.includes(dayOfWeek)) return false;
            }
            return isCorrectWeekInterval(template.date_from, dateStr, 2);
        case 'monthly':
            return matchesMonthlyRule(template.monthly_rule, dateObj);
        case 'custom':
            if (!template.recurrence_days) return false;
            return template.recurrence_days.split(',').map(d => parseInt(d.trim())).includes(dayOfWeek);
        default: return false;
    }
}
```

---

## 3. Recurrence Patterns

### 3.1 Pattern Types

| Pattern | Example | `recurrence_pattern` | `recurrence_days` | `monthly_rule` | `interval_weeks` |
|---|---|---|---|---|---|
| Weekly, specific day | Every Monday | `weekly` | `1` | NULL | 1 |
| Weekly, multiple days | Mon + Wed + Fri | `weekly` | `1,3,5` | NULL | 1 |
| Biweekly | Every other Saturday | `biweekly` | `6` | NULL | 2 |
| Monthly, Nth weekday | 1st Saturday | `monthly` | NULL | `1st_6` | NULL |
| Monthly, last weekday | Last Friday | `monthly` | NULL | `last_5` | NULL |
| Weekdays only | Mon-Fri | `weekdays` | NULL | NULL | NULL |
| Weekends only | Sat-Sun | `weekends` | NULL | NULL | NULL |
| Custom day selection | Tue + Thu | `custom` | `2,4` | NULL | NULL |

### 3.2 Monthly Rule Format

`monthly_rule` encodes "Nth weekday of month":
- `1st_6` = 1st Saturday (day 6)
- `2nd_7` = 2nd Sunday (day 7)
- `3rd_1` = 3rd Monday (day 1)
- `last_5` = Last Friday (day 5)

Implementation:
```javascript
function matchesMonthlyRule(rule, dateObj) {
    if (!rule) return false;
    const [ordinal, dayStr] = rule.split('_');
    const targetDay = parseInt(dayStr); // 1=Mon...7=Sun
    const currentDay = dateObj.getDay() || 7;
    if (currentDay !== targetDay) return false;

    const dayOfMonth = dateObj.getDate();
    const weekNum = Math.ceil(dayOfMonth / 7); // 1st, 2nd, 3rd, 4th, 5th

    if (ordinal === 'last') {
        // Check if this is the last occurrence of this weekday in the month
        const nextWeek = new Date(dateObj);
        nextWeek.setDate(dayOfMonth + 7);
        return nextWeek.getMonth() !== dateObj.getMonth();
    }

    const ordinalMap = { '1st': 1, '2nd': 2, '3rd': 3, '4th': 4, '5th': 5 };
    return weekNum === ordinalMap[ordinal];
}
```

---

## 4. Generation Logic

### 4.1 Scheduler Integration

Add new scheduler function `checkRecurringBookings()` to `services/scheduler.js`:

**When it runs:** `00:07` Kyiv time (after `checkRecurringTasks` at 00:05 and `checkRecurringAfisha` at 00:06).

**Generation horizon:** N days ahead (configurable via `settings` table, key `recurring_booking_horizon`, default: `14`).

```javascript
let recurringBookingsCreatedToday = null;

async function checkRecurringBookings() {
    const todayStr = getKyivDateStr();
    if (recurringBookingsCreatedToday === todayStr) return;

    const nowTime = getKyivTimeStr();
    if (nowTime !== '00:07') return;

    const dbLast = await getLastSent('recurring_bookings');
    if (dbLast === todayStr) { recurringBookingsCreatedToday = todayStr; return; }

    recurringBookingsCreatedToday = todayStr;
    await setLastSent('recurring_bookings', todayStr);

    await generateRecurringBookings();
}
```

### 4.2 Core Generation Algorithm

```
generateRecurringBookings():
    horizon = getSetting('recurring_booking_horizon') || 14
    templates = SELECT * FROM recurring_booking_templates WHERE is_active = true

    FOR each template:
        FOR each date in [today ... today + horizon]:
            IF NOT shouldRunOnDate(template, date): SKIP

            // Dedup: already generated?
            IF EXISTS booking WHERE recurring_template_id = template.id AND date = date: SKIP

            // Already manually skipped?
            IF EXISTS recurring_booking_skips WHERE template_id = template.id AND date = date: SKIP

            // Resolve line_id for this date
            ensureDefaultLines(date)
            primaryLineId = resolveLineByName(template.preferred_line_name, date)
            IF NOT primaryLineId: log skip, CONTINUE

            // BEGIN transaction
            client = pool.connect()
            BEGIN

            // Check conflicts (3 layers, same as manual booking)
            lineConflict = checkServerConflicts(client, date, primaryLineId, template.time, template.duration)
            IF lineConflict.overlap:
                ROLLBACK
                INSERT INTO recurring_booking_skips (template_id, date, reason, details)
                notifyAdminSkip(template, date, 'line_conflict')
                CONTINUE

            roomConflict = checkRoomConflict(client, date, template.room, template.time, template.duration)
            IF roomConflict:
                ROLLBACK
                INSERT INTO recurring_booking_skips (template_id, date, reason, details)
                notifyAdminSkip(template, date, 'room_conflict')
                CONTINUE

            // Generate main booking
            mainId = generateBookingNumber(client)
            INSERT INTO bookings (..., recurring_template_id = template.id)

            // Handle 2-animator programs (hosts > 1)
            IF template.hosts > 1 AND template.second_animator_name:
                secondLineId = resolveLineByName(template.second_animator_name, date)
                IF secondLineId:
                    secondConflict = checkServerConflicts(client, date, secondLineId, template.time, template.duration)
                    IF secondConflict.overlap:
                        ROLLBACK
                        INSERT INTO recurring_booking_skips (...)
                        notifyAdminSkip(template, date, 'second_animator_conflict')
                        CONTINUE
                    linkedId = generateBookingNumber(client)
                    INSERT INTO bookings (..., linked_to = mainId, recurring_template_id = template.id)

            // History + COMMIT
            INSERT INTO history (action='recurring_create', ...)
            COMMIT

            // Fire-and-forget: automation rules
            processBookingAutomation(booking).catch(...)

    // After all: Telegram summary (if any skips)
    notifyAdminRecurringSummary(createdCount, skippedCount, skipDetails)
```

### 4.3 Line Resolution Strategy

**Problem:** `line_id` is date-specific (`'line1_2026-03-15'`). The template stores a line **name** (e.g., "–ê–Ω—ñ–º–∞—Ç–æ—Ä 1"), not an id.

**Solution:**

```javascript
async function resolveLineByName(lineName, date) {
    if (!lineName) return null;
    // First try exact match on lines_by_date
    const result = await pool.query(
        'SELECT line_id FROM lines_by_date WHERE date = $1 AND name = $2',
        [date, lineName]
    );
    if (result.rows.length > 0) return result.rows[0].line_id;

    // Fallback: ensure default lines exist, then try again
    await ensureDefaultLines(date);
    const retry = await pool.query(
        'SELECT line_id FROM lines_by_date WHERE date = $1 AND name = $2',
        [date, lineName]
    );
    if (retry.rows.length > 0) return retry.rows[0].line_id;

    // Last resort: assign first available line
    const anyLine = await pool.query(
        'SELECT line_id FROM lines_by_date WHERE date = $1 ORDER BY line_id LIMIT 1',
        [date]
    );
    return anyLine.rows[0]?.line_id || null;
}
```

### 4.4 Each Instance = Real Booking

Every recurring instance is a **full booking** with its own `BK-YYYY-NNNN` id. This means:
- It appears on the timeline like any other booking
- It can be edited, deleted, shifted independently
- It participates in conflict checks
- It triggers Telegram notifications and automation rules
- It has its own history records

The only difference: `recurring_template_id IS NOT NULL`, which allows grouping them as a series.

---

## 5. API Endpoints

### 5.1 Template CRUD

| Method | Path | Description |
|---|---|---|
| `GET` | `/api/recurring-bookings/templates` | List all templates |
| `POST` | `/api/recurring-bookings/templates` | Create template + eager-generate for horizon |
| `PUT` | `/api/recurring-bookings/templates/:id` | Update template |
| `DELETE` | `/api/recurring-bookings/templates/:id` | Delete template |
| `POST` | `/api/recurring-bookings/templates/:id/pause` | Pause/resume (set `is_active`) |
| `POST` | `/api/recurring-bookings/templates/:id/regenerate` | Regenerate future instances |

### 5.2 Series Operations

| Method | Path | Description |
|---|---|---|
| `GET` | `/api/recurring-bookings/series/:templateId` | List all instances of a series |
| `DELETE` | `/api/recurring-bookings/series/:templateId/future?from=date` | Delete all future instances |
| `PUT` | `/api/recurring-bookings/series/:templateId/future` | Update all future instances |

### 5.3 Skip Management

| Method | Path | Description |
|---|---|---|
| `GET` | `/api/recurring-bookings/skips/:templateId` | List skips for a template |
| `POST` | `/api/recurring-bookings/skips` | Manually skip a date |
| `DELETE` | `/api/recurring-bookings/skips/:id` | Remove skip (retry generation) |

### 5.4 Route File

New file: `routes/recurring-bookings.js`, mounted in `server.js`:
```javascript
app.use('/api/recurring-bookings', authMiddleware, require('./routes/recurring-bookings'));
```

---

## 6. UI Design

### 6.1 "Make Recurring" Toggle in Booking Form

Location: bottom of `#bookingForm` in `index.html`, before the submit button.

```html
<div id="recurringSection" class="recurring-section hidden">
    <label class="toggle-label">
        <input type="checkbox" id="recurringToggle">
        <span>üîÑ –ó—Ä–æ–±–∏—Ç–∏ –ø–æ–≤—Ç–æ—Ä—é–≤–∞–Ω–∏–º</span>
    </label>

    <div id="recurringOptions" class="recurring-options hidden">
        <!-- Pattern selector -->
        <div class="form-field">
            <label>–ü–æ–≤—Ç–æ—Ä–µ–Ω–Ω—è:</label>
            <select id="recurringPattern">
                <option value="weekly">–©–æ—Ç–∏–∂–Ω—è</option>
                <option value="biweekly">–ö–æ–∂–Ω—ñ 2 —Ç–∏–∂–Ω—ñ</option>
                <option value="monthly">–©–æ–º—ñ—Å—è—Ü—è</option>
                <option value="custom">–û–±—Ä–∞—Ç–∏ –¥–Ω—ñ</option>
            </select>
        </div>

        <!-- Day selector for weekly/custom -->
        <div id="recurringDaysSection" class="form-field">
            <label>–î–Ω—ñ —Ç–∏–∂–Ω—è:</label>
            <div class="day-chips">
                <button type="button" data-day="1" class="day-chip">–ü–Ω</button>
                <button type="button" data-day="2" class="day-chip">–í—Ç</button>
                <button type="button" data-day="3" class="day-chip">–°—Ä</button>
                <button type="button" data-day="4" class="day-chip">–ß—Ç</button>
                <button type="button" data-day="5" class="day-chip">–ü—Ç</button>
                <button type="button" data-day="6" class="day-chip">–°–±</button>
                <button type="button" data-day="7" class="day-chip">–ù–¥</button>
            </div>
        </div>

        <!-- Monthly rule for monthly pattern -->
        <div id="recurringMonthlySection" class="form-field hidden">
            <label>–ü—Ä–∞–≤–∏–ª–æ:</label>
            <select id="recurringMonthlyRule">
                <!-- Dynamically populated based on selected date -->
                <!-- e.g., if selected date is 1st Saturday: "1-—à–∞ –°—É–±–æ—Ç–∞ –∫–æ–∂–Ω–æ–≥–æ –º—ñ—Å—è—Ü—è" -->
            </select>
        </div>

        <!-- End date -->
        <div class="form-field">
            <label>–î–æ –¥–∞—Ç–∏:</label>
            <input type="date" id="recurringEndDate" min="">
            <small class="hint">–ó–∞–ª–∏—à—Ç–µ –ø—É—Å—Ç–∏–º –¥–ª—è –±–µ–∑—Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ –ø–æ–≤—Ç–æ—Ä–µ–Ω–Ω—è</small>
        </div>

        <!-- Preview -->
        <div id="recurringPreview" class="recurring-preview hidden">
            <span class="label">–ù–∞—Å—Ç—É–ø–Ω—ñ –¥–∞—Ç–∏:</span>
            <div id="recurringPreviewDates"></div>
        </div>
    </div>
</div>
```

**Behavior:**
- Toggle appears only in **create** mode (not edit mode)
- When checked, `#recurringOptions` slides down
- Pattern selector auto-detects the current day and pre-selects it
- Preview shows the next 5 dates that would be generated
- On submit: creates the template + first instance (same transaction), scheduler handles the rest

### 6.2 Series Indicator on Timeline Blocks

Timeline blocks for recurring bookings get a visual indicator:

```css
.booking-block[data-recurring] {
    position: relative;
}
.booking-block[data-recurring]::after {
    content: 'üîÑ';
    position: absolute;
    top: 2px;
    right: 2px;
    font-size: 10px;
    opacity: 0.7;
}
```

In `js/timeline.js`, when rendering a booking block:
```javascript
if (booking.recurringTemplateId) {
    block.dataset.recurring = booking.recurringTemplateId;
}
```

### 6.3 Edit Dialog: Series Scope

When editing or deleting a recurring booking (identified by `recurring_template_id IS NOT NULL`), show a scope selector:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  –©–æ –∑–º—ñ–Ω–∏—Ç–∏?                     ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  ‚óã –¢—ñ–ª—å–∫–∏ —Ü–µ–π (15.03.2026)      ‚îÇ
‚îÇ  ‚óã –¶–µ–π —ñ –≤—Å—ñ –Ω–∞—Å—Ç—É–ø–Ω—ñ           ‚îÇ
‚îÇ  ‚óã –í—Å—é —Å–µ—Ä—ñ—é                     ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  [–°–∫–∞—Å—É–≤–∞—Ç–∏]  [–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏]      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**"–¢—ñ–ª—å–∫–∏ —Ü–µ–π" (this instance only):**
- Edit/delete only this one booking
- Detach from series: set `recurring_template_id = NULL` (or keep for reference but mark as "overridden" via `extra_data.recurring_overridden = true`)

**"–¶–µ–π —ñ –≤—Å—ñ –Ω–∞—Å—Ç—É–ø–Ω—ñ" (this and all future):**
- Update the template with new values
- Delete all future instances (date > selected date)
- Regenerate from selected date with new template values
- Past instances remain unchanged

**"–í—Å—é —Å–µ—Ä—ñ—é" (entire series):**
- Update the template
- Delete and regenerate ALL non-past instances
- Past instances (date < today) remain unchanged

### 6.4 Series Management Panel

New section in Settings modal (or separate modal accessible from timeline):

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üîÑ –ü–æ–≤—Ç–æ—Ä—é–≤–∞–Ω—ñ –±—Ä–æ–Ω—é–≤–∞–Ω–Ω—è                     ‚îÇ
‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ ‚îÇ –ö–í4 "–®–ø–∏–≥—É–Ω—Å—å–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—è"           ‚îÇ       ‚îÇ
‚îÇ ‚îÇ –©–æ—Ç–∏–∂–Ω—è, –°—É–±–æ—Ç–∞, 14:00, Marvel     ‚îÇ       ‚îÇ
‚îÇ ‚îÇ 2 –∞–Ω—ñ–º–∞—Ç–æ—Ä–∏: –ê–Ω—ñ–º–∞—Ç–æ—Ä 1 + –ê–Ω—ñ–º–∞—Ç–æ—Ä 2  ‚îÇ   ‚îÇ
‚îÇ ‚îÇ –∑ 01.03 –ø–æ 31.05.2026              ‚îÇ       ‚îÇ
‚îÇ ‚îÇ –ù–∞—Å—Ç—É–ø–Ω–µ: 15.03 ¬∑ –ü—Ä–æ–ø—É—â–µ–Ω–æ: 0     ‚îÇ       ‚îÇ
‚îÇ ‚îÇ [‚úèÔ∏è –†–µ–¥–∞–≥—É–≤–∞—Ç–∏] [‚è∏ –ü–∞—É–∑–∞] [üóë –í–∏–¥–∞–ª–∏—Ç–∏] ‚îÇ  ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ ‚îÇ –ú–ö "–†–æ–∑–ø–∏—Å –ø—Ä—è–Ω–∏–∫—ñ–≤"               ‚îÇ       ‚îÇ
‚îÇ ‚îÇ –©–æ—Å—É–±–æ—Ç–∏ + –©–æ–Ω–µ–¥—ñ–ª—ñ, 12:00, Elsa  ‚îÇ       ‚îÇ
‚îÇ ‚îÇ 1 –∞–Ω—ñ–º–∞—Ç–æ—Ä: –ê–Ω—ñ–º–∞—Ç–æ—Ä 1             ‚îÇ       ‚îÇ
‚îÇ ‚îÇ –ë–µ–∑—Å—Ç—Ä–æ–∫–æ–≤–æ                         ‚îÇ       ‚îÇ
‚îÇ ‚îÇ –ù–∞—Å—Ç—É–ø–Ω–µ: 15.03 ¬∑ –ü—Ä–æ–ø—É—â–µ–Ω–æ: 2     ‚îÇ       ‚îÇ
‚îÇ ‚îÇ [‚úèÔ∏è –†–µ–¥–∞–≥—É–≤–∞—Ç–∏] [‚è∏ –ü–∞—É–∑–∞] [üóë –í–∏–¥–∞–ª–∏—Ç–∏] ‚îÇ  ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ [+ –°—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–µ –ø–æ–≤—Ç–æ—Ä–µ–Ω–Ω—è]                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 6.5 Booking Details Enhancement

In `showBookingDetails()`, for recurring bookings, add:

```html
<div class="booking-detail-row">
    <span class="label">–°–µ—Ä—ñ—è:</span>
    <span class="value">üîÑ –©–æ—Ç–∏–∂–Ω—è, –°—É–±–æ—Ç–∞ (—à–∞–±–ª–æ–Ω #5)</span>
</div>
```

And in action buttons:
```html
<button onclick="editRecurringSeries('${booking.id}')">üîÑ –°–µ—Ä—ñ—è</button>
```

---

## 7. Edge Cases

### 7.1 Room Conflict on Specific Date

**Decision: SKIP + NOTIFY**

When a recurring booking cannot be created on a specific date due to room conflict:
1. Log the skip in `recurring_booking_skips` table
2. Send Telegram notification to admin group
3. Continue generating other dates
4. Show skip count in the management panel

Admin can then:
- Change the room for that date (manual booking)
- Or retry generation after resolving the conflict

### 7.2 Animator Unavailable on One Date

**Problem:** The preferred animator line may have a conflict or may not exist on a specific date (animator is on dayoff/vacation/sick).

**Strategy:**
1. First: try the preferred line
2. If conflict: check if the template has `second_animator_name` that could swap roles
3. If still no: SKIP + log + notify
4. Do NOT auto-assign to a different animator (too risky for customer-facing business)

**Integration with staff_schedule (v7.10):**
```javascript
// Before generating: check if the animator is available
const staffCheck = await pool.query(
    `SELECT ss.status FROM staff s
     JOIN staff_schedule ss ON s.id = ss.staff_id
     WHERE s.name = $1 AND ss.date = $2`,
    [animatorName, date]
);
if (staffCheck.rows[0]?.status !== 'working') {
    // Skip with reason 'animator_unavailable'
}
```

### 7.3 Template Modification -> Regenerate Future?

**Decision: YES, with explicit user action**

When a template is updated:
1. Show confirmation: "–û–Ω–æ–≤–∏—Ç–∏ –≤—Å—ñ –º–∞–π–±—É—Ç–Ω—ñ –±—Ä–æ–Ω—é–≤–∞–Ω–Ω—è —Ü—ñ—î—ó —Å–µ—Ä—ñ—ó?"
2. If YES: delete future instances (date >= today), regenerate with new template data
3. If NO: only new instances going forward will use updated template
4. Past instances are NEVER modified

### 7.4 Delete Single vs Delete Series

**Single delete:**
- Mark as cancelled (soft delete, same as now)
- Keep `recurring_template_id` so it's not re-generated
- Or: insert into `recurring_booking_skips` with `reason = 'manual_skip'`

**Series delete:**
- Soft-delete all future instances
- Set `is_active = false` on the template
- Past instances remain (for history/reporting)

### 7.5 Linked Bookings in Recurring Context

**Critical complexity:** A 2-animator program (e.g., –ö–í4, hosts=2) creates:
- Main booking on Animator 1's line
- Linked booking on Animator 2's line

For recurring:
- The template stores `second_animator_name` (not line_id)
- At generation time, resolve both animators to their date-specific line_ids
- If EITHER has a conflict ‚Üí skip the entire instance (main + linked)
- Both bookings get `recurring_template_id` set
- Both bookings share the same linked_to relationship

**Extra host (pinata filler) in recurring:**
- If the template has pinata_filler: create the linked "extra host" booking as well
- Template stores `pinata_filler` value, used for each instance

### 7.6 Manual Edit of a Recurring Instance

When a user edits a single instance:
- The booking remains linked to the template (`recurring_template_id` stays)
- But: add `extra_data.recurring_overridden = true` to flag it
- Scheduler will NOT overwrite manually edited instances during regeneration
- Dedup check: `WHERE recurring_template_id = $1 AND date = $2` ‚Äî if exists, skip (whether overridden or not)

### 7.7 Line Rename Between Dates

If "–ê–Ω—ñ–º–∞—Ç–æ—Ä 1" is renamed to "–í–∞–ª–µ—Ä—ñ—è" on some dates:
- Template stores the name at creation time
- `resolveLineByName()` handles the resolution
- If the name no longer exists for a future date, fall back to first available line
- Admin notification: "–õ—ñ–Ω—ñ—é '{name}' –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ –Ω–∞ {date}, –ø—Ä–∏–∑–Ω–∞—á–µ–Ω–æ –Ω–∞ {fallback}"

---

## 8. Telegram Notifications

### 8.1 Generation Summary (Daily)

Sent after the generation run (as part of scheduler):

```
üîÑ –ü–æ–≤—Ç–æ—Ä—é–≤–∞–Ω—ñ –±—Ä–æ–Ω—é–≤–∞–Ω–Ω—è –Ω–∞ 15.03-28.03

‚úÖ –°—Ç–≤–æ—Ä–µ–Ω–æ: 8
‚îú –ö–í4 –®–ø–∏–≥—É–Ω—Å—å–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—è ‚Äî –°–± 15.03, 22.03
‚îú –ú–ö –ü—Ä—è–Ω–∏–∫–∏ ‚Äî –°–± 15.03, 22.03 + –ù–¥ 16.03, 23.03
‚îî –ë—É–ª—å–±–∞—à–∫–æ–≤–µ —à–æ—É ‚Äî –°–± 15.03, 22.03

‚ö†Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–æ: 2
‚îú –ö–í4 29.03 ‚Äî –∫—ñ–º–Ω–∞—Ç–∞ Marvel –∑–∞–π–Ω—è—Ç–∞ (üé™ –î–µ–Ω—å –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è)
‚îî –ú–ö –ü—Ä—è–Ω–∏–∫–∏ 29.03 ‚Äî –ê–Ω—ñ–º–∞—Ç–æ—Ä 1 –Ω–∞ –≤–∏—Ö—ñ–¥–Ω–æ–º—É
```

### 8.2 Skip Notification (Immediate)

For high-priority conflicts, send immediately:

```
‚ö†Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–æ –ø–æ–≤—Ç–æ—Ä—é–≤–∞–Ω–µ –±—Ä–æ–Ω—é–≤–∞–Ω–Ω—è

üìã –ö–í4 "–®–ø–∏–≥—É–Ω—Å—å–∫–∞ —ñ—Å—Ç–æ—Ä—ñ—è"
üìÖ 29.03.2026 –æ 14:00
üè† Marvel ‚Äî –∑–∞–π–Ω—è—Ç–∞: üéÇ –î–ù –ê–ª—ñ–Ω–∞ –æ 13:30
üîÑ –°–µ—Ä—ñ—è: –©–æ—Ç–∏–∂–Ω—è, –°—É–±–æ—Ç–∞

–ü–æ—Ç—Ä—ñ–±–Ω–æ –≤—Ä—É—á–Ω—É —Å—Ç–≤–æ—Ä–∏—Ç–∏ –∞–±–æ –∑–º—ñ–Ω–∏—Ç–∏ –∫—ñ–º–Ω–∞—Ç—É.
```

### 8.3 Digest Integration

In the daily digest, recurring bookings appear exactly like regular bookings (they ARE regular bookings). No special formatting needed ‚Äî the `üîÑ` indicator is only in the web UI.

---

## 9. Implementation Order

### Phase 1: Database + Backend (estimated: 1 session)
1. Create `recurring_booking_templates` table in `db/index.js`
2. Add `recurring_template_id` column to `bookings` table
3. Create `recurring_booking_skips` table
4. Extract `shouldRunOnDate()` into `utils/recurrence.js` (refactor afisha + task templates to use it)
5. Create `routes/recurring-bookings.js` with template CRUD
6. Mount route in `server.js`
7. Add `mapBookingRow()` support for `recurringTemplateId`

### Phase 2: Generation Logic (estimated: 1 session)
1. Implement `generateRecurringBookings()` in `services/recurringBookings.js`
2. Implement `resolveLineByName()` helper
3. Handle main + linked booking generation within transaction
4. Implement conflict detection + skip logging
5. Add `checkRecurringBookings()` to scheduler
6. Register in `server.js` scheduler interval
7. Write tests for generation logic

### Phase 3: Frontend - Create Flow (estimated: 1 session)
1. Add recurring section to booking form in `index.html`
2. Implement pattern selector + day chips in `js/booking.js`
3. Preview of upcoming dates
4. Submit flow: create template + first instance
5. CSS styling in `css/panel.css`

### Phase 4: Frontend - Timeline + Edit (estimated: 1 session)
1. Add `üîÑ` indicator to timeline blocks in `js/timeline.js`
2. Implement series scope dialog ("–¢—ñ–ª—å–∫–∏ —Ü–µ–π" / "–í—Å—ñ –Ω–∞—Å—Ç—É–ø–Ω—ñ" / "–í—Å—é —Å–µ—Ä—ñ—é")
3. Wire edit/delete to appropriate API calls
4. Add series management panel to settings modal
5. CSS styling for series cards

### Phase 5: Telegram + Polish (estimated: 0.5 session)
1. Implement skip notifications
2. Implement daily generation summary
3. Integration with `processBookingAutomation()` for each generated instance
4. Add recurring booking tests to `tests/api.test.js`
5. Update `SNAPSHOT.md`, `CHANGELOG.md`, `PROJECT_PASSPORT.md`

---

## 10. Cross-Dependencies with Other Features

### 10.1 Feature #1 ‚Äî (Booking Automation Rules, v8.3)

**Status:** Already implemented in `services/bookingAutomation.js`.

**Impact:** Each recurring instance is a real booking, so automation rules fire for each generated instance. This is the desired behavior:
- –ú–ö –§—É—Ç–±–æ–ª–∫–∏ recurring ‚Üí creates task "–£—Ç–æ—á–Ω–∏—Ç–∏ —Ä–æ–∑–º—ñ—Ä–∏" for EACH instance date
- –ü—ñ–Ω—å—è—Ç–∞ recurring ‚Üí creates task "–ó–∞–º–æ–≤–∏—Ç–∏ –¥—Ä—É–∫" for EACH instance

**Consideration:** `days_before` in automation rules should work correctly because each instance has a concrete `date`. The automation scheduler already checks by date proximity.

**No changes needed** in automation ‚Äî it treats recurring instances the same as manual bookings.

### 10.2 Feature #8 ‚Äî (Afisha Recurring Templates, v8.0)

**Status:** Already implemented in `routes/afisha.js` + `services/scheduler.js`.

**Reuse opportunities:**
- `shouldTemplateRunOnDate()` logic ‚Üí extract to shared `utils/recurrence.js`
- `ensureRecurringAfishaForDate()` pattern ‚Üí model for `ensureRecurringBookingsForDateRange()`
- In-memory cache with TTL ‚Üí reuse same pattern for booking template cache
- DB "last sent" pattern ‚Üí reuse `getLastSent/setLastSent` for `'recurring_bookings'` key

**Migration:** Refactor `routes/afisha.js` and `services/scheduler.js` to import from `utils/recurrence.js` instead of inlining `shouldTemplateRunOnDate()`.

### 10.3 Feature #10 ‚Äî (Staff Schedule, v7.10)

**Status:** Already implemented: `staff` + `staff_schedule` tables, `routes/staff.js`.

**Integration for recurring bookings:**
- Before generating a recurring instance, check `staff_schedule` for the animator's availability on that date
- If animator has `status = 'dayoff' | 'vacation' | 'sick'` ‚Üí skip generation + notify
- The check in `js/booking.js` (`checkAnimatorAvailability()`) already exists for manual bookings; extend it to recurring generation

**Data flow:**
```
recurring generation ‚Üí resolveLineByName(animatorName, date)
                     ‚Üí check staff_schedule for that date
                     ‚Üí if unavailable: skip + log reason
```

### 10.4 Feature #14 ‚Äî (Unknown, needs clarification)

**Assumed: Export/Reports or Financial Module**

If Feature #14 involves reporting:
- Recurring bookings should be filterable in reports by `recurring_template_id IS NOT NULL`
- Revenue projections: multiply template price by number of scheduled instances
- "Recurring vs one-time" breakdown in dashboard stats

If Feature #14 involves client CRM / contacts:
- Recurring bookings can be linked to a client: `group_name` field already exists
- Template could store `client_id` for future CRM integration

**Action:** Clarify Feature #14 scope to determine exact integration points.

---

## 11. Testing Plan

### 11.1 API Tests (add to `tests/api.test.js`)

```
Suite: Recurring Booking Templates
  ‚úì POST /api/recurring-bookings/templates ‚Äî create template
  ‚úì POST /api/recurring-bookings/templates ‚Äî validation (missing fields)
  ‚úì GET /api/recurring-bookings/templates ‚Äî list all
  ‚úì PUT /api/recurring-bookings/templates/:id ‚Äî update
  ‚úì DELETE /api/recurring-bookings/templates/:id ‚Äî delete
  ‚úì POST /api/recurring-bookings/templates/:id/pause ‚Äî toggle active

Suite: Recurring Booking Generation
  ‚úì Generate instances for weekly pattern
  ‚úì Generate instances for biweekly pattern
  ‚úì Generate instances for monthly pattern
  ‚úì Generate with 2-animator program (main + linked)
  ‚úì Skip on line conflict
  ‚úì Skip on room conflict
  ‚úì Dedup ‚Äî don't generate if instance exists
  ‚úì Respect date_from / date_to bounds
  ‚úì Handle missing line (fallback)

Suite: Series Operations
  ‚úì GET /api/recurring-bookings/series/:templateId ‚Äî list instances
  ‚úì DELETE series future ‚Äî removes future instances
  ‚úì PUT series future ‚Äî updates future instances
  ‚úì Edit single instance ‚Äî detaches from series
  ‚úì Delete single instance ‚Äî adds to skips

Suite: Edge Cases
  ‚úì Template with pinata_filler generates correctly
  ‚úì Template with extra_data (tshirt_sizes) passes to instances
  ‚úì Inactive template is not generated
  ‚úì Expired template (date_to < today) is not generated
```

### 11.2 Manual Test Scenarios

1. **Create recurring –ö–í4 (2 animators) every Saturday** ‚Üí verify main + linked appear on all Saturdays
2. **Room conflict on one Saturday** ‚Üí verify skip + Telegram notification
3. **Edit one instance** ‚Üí verify only that instance changes
4. **Delete series** ‚Üí verify all future instances cancelled
5. **Pause + resume template** ‚Üí verify generation stops/starts
6. **Change room on template** ‚Üí regenerate future ‚Üí verify new room applied
7. **Verify timeline indicator** ‚Üí `üîÑ` appears on recurring blocks

---

## 12. Data Size Considerations

**Estimation:**
- 10 recurring templates, weekly, 1 year = ~520 booking rows per year per template
- With 2-animator programs: ~1040 rows (main + linked)
- 10 templates * 1040 = ~10,400 additional rows per year
- Current bookings table handles this easily (indexed on `date` and `recurring_template_id`)

**Cleanup strategy:**
- Scheduler generates only N days ahead (default 14)
- Past instances are never deleted (audit trail)
- Skips table auto-cleans: delete skips older than 90 days

---

## 13. Open Questions

1. **Default generation horizon:** 14 days or 30 days? (14 aligns with afisha horizon)
2. **Feature #14 scope:** What is it? Needed for exact integration plan.
3. **Notification frequency:** One daily summary or immediate per-skip? (Plan proposes both: immediate for conflicts, daily summary for stats)
4. **Template limit:** Should we cap the number of active templates? (Proposed: 20 max, shown in UI)
5. **Holidays handling:** Should recurring bookings skip Ukrainian public holidays automatically? (e.g., Dec 25, Jan 1, etc.)
6. **Price changes:** If a product's price changes in the catalog, should future recurring instances use the old (template) price or the new catalog price? (Proposed: template price, since it was agreed at creation time)

---

*End of plan. Ready for implementation upon approval.*
